<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adrian Alamo – Projects</title>
    <meta name="description" content="Selected projects by Adrian Alamo across ML, algorithms, and full‑stack." />
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="styles.css?v=4">
</head>
<body>
    <nav class="nav">
        <div class="container nav-inner">
            <a class="brand" href="index.html"><span class="brand-logo"></span> <span>Adrian Alamo</span></a>
            <ul>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="resume.html">Resume</a></li>
                <li><a href="about.html">About</a></li>
            </ul>
        </div>
    </nav>

    <main class="container content">
        <h1>Projects</h1>
        <p class="lead">Selected work across ML, systems, and full‑stack. <br><b>GitHub repository available upon request for private review.</b><br><b>Contact me for more information.</b></p>

        <div class="card-grid">
            <div class="card project-card" 
                 data-title="Language Identification with RNNs"
                 data-description="Designed and implemented a character-level Recurrent Neural Network (RNN) model for language identification across 5 languages (English, Spanish, Finnish, Dutch, Polish). The architecture uses LSTM cells with embedding layers to handle variable-length sequences, processing words character-by-character across 47 unique character classes. Implemented sequence padding and masking to efficiently batch variable-length inputs. The model maintains O(n) time complexity per word where n is the sequence length, using hidden state vectors and backpropagation through time (BPTT) for training. Achieved >90% accuracy on test sets, demonstrating strong performance in sequence classification tasks. Data structures utilized include dynamic arrays for batch processing, hash maps for character-to-index mappings, and tensor operations for efficient matrix computations."
                 data-github="https://github.com/yourusername/language-id-rnn">
                <h3>Language Identification with RNNs</h3>
                <p>Character‑level RNN for 5‑language word classification (>90% accuracy).</p>
                <div class="tags"><span class="tag">Python</span><span class="tag">ML</span><span class="tag">RNN</span></div>
            </div>
            <div class="card project-card"
                 data-title="Pac‑Man Reinforcement Learning"
                 data-description="Implemented three distinct reinforcement learning agents using dynamic programming and probabilistic inference. Value Iteration Agent uses Bellman equations with O(S²A) complexity where S is state space and A is action space, employing iterative updates until convergence to optimal policy. Q-Learning Agent implements temporal difference learning with epsilon-greedy exploration, using hash maps (dictionaries) for O(1) Q-value lookups and updates, with learning rate decay for convergence. Bayes Net Agent utilizes probabilistic inference with variable elimination, maintaining belief states over ghost locations using conditional probability tables stored in hash maps. All agents process game states represented as multi-dimensional arrays, with efficient state encoding to reduce memory footprint. Achieved optimal performance through careful tuning of discount factors, learning rates, and exploration strategies."
                 data-github="https://github.com/yourusername/pacman-rl">
                <h3>Pac‑Man Reinforcement Learning</h3>
                <p>Value Iteration and Q‑Learning agents for maze navigation.</p>
                <div class="tags"><span class="tag">Reinforcement Learning</span><span class="tag">NumPy</span></div>
            </div>
            <div class="card project-card"
                 data-title="End‑to‑End Encrypted File Sharing"
                 data-description="Designed and implemented a production-ready client application API for secure file sharing using Golang with comprehensive cryptographic protocols. Architecture employs RSA-2048 public key encryption (O(k³) where k is key size) for key exchange, AES-256 symmetric encryption (O(n) where n is file size) for bulk data encryption, and SHA-256 hashing (O(n)) for data integrity verification. Implemented digital signatures using RSA-PSS for non-repudiation, with O(1) signature verification through hash map lookups of public keys. The system uses hash tables (maps) for O(1) user authentication, access control lists (ACLs) stored in hash maps for efficient permission checks, and Merkle trees for file versioning with O(log n) verification. File metadata stored in structured hash maps enables O(1) lookups for file access, sharing permissions, and user management. All cryptographic operations handle large files efficiently through streaming and chunked processing to maintain constant memory usage."
                 data-github="https://github.com/yourusername/secure-file-sharing">
                <h3>End‑to‑End Encrypted File Sharing</h3>
                <p>Client API with RSA, signatures, and access control.</p>
                <div class="tags"><span class="tag">Golang</span><span class="tag">Crypto</span></div>
            </div>
            <div class="card project-card"
                 data-title="Network Traceroute Implementation"
                 data-description="Implemented a network traceroute utility from scratch using raw sockets and ICMP protocol. The algorithm systematically increments Time-To-Live (TTL) values starting from 1, sending UDP packets and waiting for ICMP Time Exceeded responses to map each hop. Uses socket programming with non-blocking I/O and timeout mechanisms for O(n) complexity where n is the number of hops. Implemented efficient data structures including queues for packet tracking, hash maps for storing round-trip times (RTTs) per hop, and arrays for maintaining route information. Handles network edge cases such as packet loss, duplicate responses, and asymmetric routing paths. The implementation demonstrates deep understanding of network stack layers, IP protocol headers, and low-level socket operations in Python."
                 data-github="https://github.com/yourusername/traceroute">
                <h3>Network Traceroute Implementation</h3>
                <p>Built a traceroute tool to map network paths by adjusting TTL values and analyzing ICMP responses.</p>
                <div class="tags"><span class="tag">Python</span><span class="tag">Network</span></div>
            </div>
            <div class="card project-card"
                 data-title="Distance Vector Routing Algorithm"
                 data-description="Implemented the Distance Vector Routing Algorithm (Bellman-Ford variant) for distributed network routing. The algorithm uses dynamic programming with O(V*E) time complexity in worst case, where V is the number of vertices (nodes) and E is the number of edges (links). Each node maintains a distance vector (routing table) stored as a hash map for O(1) lookups and updates, containing shortest path distances to all destinations. Implements split horizon and poison reverse techniques to prevent count-to-infinity problems and routing loops. The system exchanges routing updates periodically using adjacency lists (graphs represented as hash maps of lists) for efficient neighbor iteration. Convergence detection uses vector comparison algorithms to detect when routing tables stabilize. Handles network topology changes dynamically, updating routes in O(V) time per update cycle. Demonstrates understanding of distributed algorithms, graph theory, and network protocol design."
                 data-github="https://github.com/yourusername/distance-vector-routing">
                <h3>Distance Vector Routing Algorithm</h3>
                <p>Distance-vector routing protocol in Python with dynamic route updates, split horizon, and poison reverse for efficient and loop-free packet forwarding.</p>
                <div class="tags"><span class="tag">Python</span><span class="tag">Network</span></div>
            </div>
            <div class="card project-card"
                 data-title="Bear Maps"
                 data-description="Built a full-stack web mapping application backend for the city of Berkeley using Java, implementing Google Maps-like functionality. The A* pathfinding algorithm uses a min-heap (priority queue) for efficient node selection with O((V + E) log V) time complexity, where V is vertices and E is edges, providing optimal shortest path calculations. Implemented a k-dimensional (2D) KD-tree data structure for O(log n) average case spatial search operations, enabling fast point-of-interest lookups and zoom-level optimization. The KD-tree recursively partitions the 2D space, using alternating dimension comparisons to achieve balanced tree structure. Graph representation uses adjacency lists (hash maps of lists) for O(1) edge lookups and efficient traversal. Raster tile rendering implements quad-tree-based level-of-detail (LOD) system for optimal map tile loading at different zoom levels. Route caching uses hash maps for O(1) lookup of frequently requested paths. The system handles millions of geographic coordinates efficiently through spatial indexing and graph algorithms."
                 data-github="https://github.com/yourusername/bearmaps">
                <h3>Bear Maps</h3>
                <p>Java web mapping backend with A* routing and KD‑Tree search.</p>
                <div class="tags"><span class="tag">Java</span><span class="tag">Algorithms</span></div>
            </div>
            <div class="card project-card"
                 data-title="Sixteen Car Project"
                 data-description="Designed and implemented a voice-controlled autonomous car system from scratch, integrating hardware (TI LaunchPad microcontroller) with custom software algorithms. Implemented PID (Proportional-Integral-Derivative) control system with O(1) time complexity per control cycle for real-time wheel velocity adjustment. Data acquisition uses encoder sensors with interrupt-driven event handling, storing wheel rotation data in circular buffers for O(1) insertion and O(n) batch processing. Implemented closed-loop feedback control with Kalman filtering for noise reduction, using state vectors and covariance matrices to estimate true wheel positions from noisy sensor data. Signal processing pipeline includes linearization algorithms to convert nonlinear sensor responses to linear control inputs, using lookup tables (hash maps) for O(1) calibration data access. Motor control uses pulse-width modulation (PWM) with duty cycle calculations for precise speed control. The system processes voice commands through pattern recognition, converting audio signals to control commands with low latency for real-time response."
                 data-github="https://github.com/yourusername/sixteen-car-project">
                <h3>Sixteen Car Project</h3>
                <p>Voice controlled car with closed loop system and linearization.</p>
                <div class="tags"><span class="tag">Python</span><span class="tag">Embedded Systems</span><span class="tag">Circuit Design</span></div>
            </div>
            <div class="card project-card"
                 data-title="Multithreaded Operating System"
                 data-description="Implemented a multithreaded operating system kernel in C (PintOS framework) with comprehensive system-level functionality. Thread scheduling uses multi-level feedback queues (MLFQ) with O(log n) priority queue operations for efficient task scheduling, implementing round-robin and priority-based algorithms. Process control blocks (PCBs) stored in hash maps for O(1) process lookup by PID. Memory management implements virtual memory with page tables, using two-level page table structure for O(1) virtual-to-physical address translation, with page replacement algorithms including LRU (Least Recently Used) using doubly-linked lists for O(1) updates. File system implementation includes inode-based structure with bitmap allocation (O(n) for free block search) and directory entries stored as hash maps for O(1) filename lookups. Inter-process communication (IPC) uses semaphores and mutexes with wait queues (linked lists) for blocking synchronization, achieving O(1) lock acquisition in uncontested cases. System calls implemented with trap handlers and kernel mode switches, maintaining isolation between user and kernel space."
                 data-github="https://github.com/yourusername/os-project">
                <h3>Multithreaded Operating System</h3>
                <p>Operating system in C with kernel-user modes, thread scheduling, and process management.</p>
                <div class="tags"><span class="tag">C</span><span class="tag">PintOS</span></div>
            </div>
            <div class="card project-card"
                 data-title="Movie Classification"
                 data-description="Implemented a k-Nearest Neighbors (KNN) classifier from scratch for movie genre classification with comprehensive data analysis. The KNN algorithm uses distance metrics (Euclidean and Manhattan) with O(n*k) time complexity where n is training set size and k is number of neighbors, using k-d trees for optimized O(log n) neighbor search in high-dimensional feature spaces. Feature engineering involved data normalization using z-score standardization stored in NumPy arrays for vectorized operations. Implemented cross-validation with stratified k-fold splitting to prevent data leakage and ensure robust evaluation. Data preprocessing uses pandas DataFrames for efficient manipulation, handling missing values with imputation algorithms, and encoding categorical features using one-hot encoding. Feature selection uses correlation matrices and mutual information to identify optimal feature subsets. Model evaluation includes confusion matrices, precision-recall curves, and F1-score calculations. Visualization pipeline creates statistical plots using Matplotlib, including distribution plots, correlation heatmaps, and ROC curves to analyze classifier performance and feature relationships. Achieved high classification accuracy through hyperparameter tuning of k values and distance metrics."
                 data-github="https://github.com/yourusername/movie-classification">
                <h3>Movie Classification</h3>
                <p>KNN classifier with exploratory analysis and visualization.</p>
                <div class="tags"><span class="tag">Python</span><span class="tag">Pandas</span></div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">© <span data-year></span> Adrian Alamo</div>
    </footer>

    <!-- Project Modal -->
    <div id="project-modal" class="modal" role="dialog" aria-labelledby="modal-title" aria-hidden="true">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <button class="modal-close" aria-label="Close modal">&times;</button>
            <h2 id="modal-title"></h2>
            <div id="modal-description"></div>
        </div>
    </div>

    <script src="script.js?v=4"></script>
</body>
</html>